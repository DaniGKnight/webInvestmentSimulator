<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Investment Simulator Game</title>
    <!-- Tailwind CSS for modern styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c;
            color: #e2e8f0;
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            background-color: #2d3748;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .container {
            max-width: 90vw;
            margin: 0 auto;
        }
        #crosshair-date {
            position: absolute;
            bottom: 0px;
            left: 50%;
            transform: translateX(-50%);
            padding: 4px 8px;
            background-color: #4b5563;
            color: white;
            font-size: 12px;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        #crosshair-price {
            position: absolute;
            right: 0px;
            top: 50%;
            transform: translateY(-50%);
            padding: 4px 8px;
            background-color: #4b5563;
            color: white;
            font-size: 12px;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 10;
        }
        #crosshair-close-price {
            position: absolute;
            top: 60px;
            left: 70px;
            padding: 4px 8px;
            background-color: #4b5563;
            color: #fff;
            font-size: 12px;
            border-radius: 6px;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 20;
            font-weight: 600;
        }

        /* Custom table styling for positions and history */
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #4b5563;
        }
        th {
            background-color: #374151;
            font-weight: 600;
        }
        tr:hover {
            background-color: #3e4757;
        }

        /* Hide the number input arrows */
        input[type="number"]::-webkit-outer-spin-button,
        input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }

        .hidden {
            display: none;
        }
    </style>
</head>
<body class="p-4 sm:p-8 flex flex-col items-center justify-center min-h-screen">

    <!-- Main container -->
    <div class="container bg-gray-800 p-6 sm:p-8 rounded-xl shadow-lg w-full max-w-4xl">
        
        <!-- Start Screen -->
        <div id="startScreen" class="flex flex-col items-center justify-center text-center">
            <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-white">Investment Game</h1>
            <p class="mb-6 text-gray-400">Select your stock, funds, and end date to begin the simulation.</p>
            
            <div class="flex flex-col sm:flex-row items-center justify-center space-y-4 sm:space-y-0 sm:space-x-4 mb-6 w-full">
                <!-- Stock selection dropdown -->
                <div class="w-full sm:w-auto flex items-center space-x-2">
                    <label for="stockSelector" class="text-sm font-medium text-gray-300 whitespace-nowrap">Stock:</label>
                    <select id="stockSelector" class="form-select rounded-lg border-gray-600 bg-gray-700 text-gray-100 p-2 focus:ring-2 focus:ring-violet-500 focus:border-transparent transition-colors duration-200" disabled>
                        <option value="">Loading stocks...</option>
                    </select>
                </div>

                <!-- Funds input -->
                <div class="w-full sm:w-auto flex items-center space-x-2">
                    <label for="startFunds" class="text-sm font-medium text-gray-300 whitespace-nowrap">Start Funds ($):</label>
                    <input type="number" id="startFunds" class="w-24 form-input rounded-lg border-gray-600 bg-gray-700 text-gray-100 p-2 text-center" value="10000" min="1000" step="1000">
                </div>
            </div>

            <!-- Date picker -->
            <div class="w-full sm:w-auto flex items-center space-x-2">
                <label for="datePicker" class="text-sm font-medium text-gray-300 whitespace-nowrap">End Date:</label>
                <input type="date" id="datePicker" class="form-input rounded-lg border-gray-600 bg-gray-700 text-gray-100 p-2 focus:ring-2 focus:ring-violet-500 focus:border-transparent transition-colors duration-200" disabled>
            </div>

            <button id="startGameBtn" class="mt-8 px-6 py-3 rounded-full font-bold bg-green-600 hover:bg-green-700 transition-colors" disabled>Start Game</button>
            <div id="startMessageArea" class="mt-4 text-red-400 font-semibold hidden"></div>
        </div>
        
        <!-- Game Screen -->
        <div id="gameScreen" class="hidden">
            <h1 class="text-3xl sm:text-4xl font-bold mb-4 text-center text-white">Investment Simulator</h1>

            <!-- Button bar above the chart -->
            <div class="flex flex-row justify-end items-center w-full mb-4 space-x-2">
                <!-- Day navigation button -->
                <div class="flex space-x-1 sm:space-x-2 w-full justify-end">
                    <button id="nextDayBtn" class="text-sm sm:text-base flex-1 sm:flex-none px-4 py-2 rounded-full font-bold bg-violet-600 hover:bg-violet-700 transition-colors" disabled>Next Day</button>
                </div>
            </div>
            
            <!-- Chart and message area -->
            <div class="relative w-full h-[300px] sm:h-[500px]">
                <canvas id="chartCanvas" class="w-full h-full"></canvas>
                
                <!-- New element to display the closing price of the day -->
                <div id="crosshair-close-price"></div>
                
                <div id="messageArea" class="absolute inset-0 flex items-center justify-center bg-gray-800 bg-opacity-70 rounded-xl transition-opacity duration-300 hidden">
                    <p class="text-lg font-semibold text-white">Loading data...</p>
                </div>
                <!-- Elements to display crosshair info -->
                <div id="crosshair-date"></div>
                <div id="crosshair-price"></div>
            </div>

            <!-- Investment Controls Panel -->
            <div class="bg-gray-700 p-4 sm:p-6 rounded-xl shadow-md mt-6 w-full">
                <h2 class="text-xl font-bold mb-4 text-white">Investment Control</h2>
                <!-- Use a single column layout with wrapping for mobile -->
                <div class="flex flex-col sm:flex-row items-center justify-between space-y-4 sm:space-y-0">
                    <div class="flex items-center space-x-2 w-full sm:w-auto justify-center">
                        <label for="investAmount" class="text-sm font-medium text-gray-300 whitespace-nowrap">Max Investment ($):</label>
                        <button id="minusBtn" class="px-2 py-1 rounded-lg bg-gray-600 hover:bg-gray-500 text-white font-bold transition-colors">-</button>
                        <input type="number" id="investAmount" class="w-24 form-input rounded-lg border-gray-600 bg-gray-800 text-gray-100 p-2 text-center" value="1000" min="1000" step="1000">
                        <button id="plusBtn" class="px-2 py-1 rounded-lg bg-gray-600 hover:bg-gray-500 text-white font-bold transition-colors">+</button>
                    </div>
                    <!-- Buttons are stacked on top of each other on mobile -->
                    <div class="flex flex-row space-x-4 w-full sm:w-auto justify-center mt-4 sm:mt-0">
                        <button id="buyBtn" class="w-full sm:w-auto px-6 py-2 rounded-full font-bold bg-green-600 hover:bg-green-700 transition-colors" disabled>BUY</button>
                        <button id="sellBtn" class="w-full sm:w-auto px-6 py-2 rounded-full font-bold bg-red-600 hover:bg-red-700 transition-colors" disabled>SELL</button>
                    </div>
                </div>
            </div>

            <!-- Portfolio and Summary Panel -->
            <div class="bg-gray-700 p-4 sm:p-6 rounded-xl shadow-md mt-6 w-full">
                <h2 class="text-xl font-bold mb-4 text-white">My Portfolio</h2>
                <!-- Grid columns now become a single column on mobile -->
                <div class="grid grid-cols-1 sm:grid-cols-4 gap-4 mb-4">
                    <div class="bg-gray-800 p-4 rounded-lg text-center">
                        <p class="text-sm text-gray-400">Total Invested</p>
                        <p id="totalInvested" class="text-xl font-bold text-gray-100">$0.00</p>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center">
                        <p class="text-sm text-gray-400">Remaining Funds</p>
                        <p id="remainingFunds" class="text-xl font-bold text-gray-100">$0.00</p>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center">
                        <p class="text-sm text-gray-400">Liquidation Value</p>
                        <p id="liquidationValue" class="text-xl font-bold text-gray-100">$0.00</p>
                    </div>
                    <div class="bg-gray-800 p-4 rounded-lg text-center">
                        <p class="text-sm text-gray-400">Realized P&L</p>
                        <p id="realizedPnL" class="text-xl font-bold text-gray-100">$0.00</p>
                    </div>
                </div>
                <div class="overflow-x-auto">
                    <table id="positionsTable" class="min-w-full text-sm">
                        <thead>
                            <tr>
                                <th>Stock</th>
                                <th>Shares</th>
                                <th>Avg. Price</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Positions will be injected here -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- History Panel -->
            <div class="bg-gray-700 p-4 sm:p-6 rounded-xl shadow-md mt-6 w-full">
                <h2 class="text-xl font-bold mb-4 text-white">Transaction History</h2>
                <div class="overflow-x-auto">
                    <table id="historyTable" class="min-w-full text-sm">
                        <thead>
                            <tr>
                                <th>Date</th>
                                <th>Order</th>
                                <th>#</th>
                                <th>Price</th>
                                <th>P&L</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- History will be injected here -->
                        </tbody>
                    </table>
                </div>
            </div>

        </div>

    </div>

    <script>
        // Use an IIFE (Immediately Invoked Function Expression) to avoid global scope pollution
        (function() {
            // --- Global State Variables ---
            let allStockData = [];
            let stockData = [];
            let currentIndex = -1;
            let canvas, ctx;
            let chartWidth, chartHeight;
            let dataToDisplay = [];
            let minPrice, maxPrice, priceScale;
            const monthNames = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            
            // --- Simulator State Variables ---
            let portfolio = {};
            let transactionHistory = [];
            let totalInvestedAmount = 0;
            let totalRealizedPnL = 0;
            let startFunds = 0;
            let remainingFunds = 0;
            let liquidationValue = 0;

            // --- GitHub API Configuration ---
            // The URL has been updated to use the repository you provided.
            const githubApiUrl = 'https://api.github.com/repos/DaniGKnight/webInvestmentSimulator/contents/stock_data';
            
            // --- DOM Elements ---
            const datePicker = document.getElementById('datePicker');
            const nextDayBtn = document.getElementById('nextDayBtn');
            const messageArea = document.getElementById('messageArea');
            const crosshairDateEl = document.getElementById('crosshair-date');
            const crosshairPriceEl = document.getElementById('crosshair-price');
            const crosshairClosePriceEl = document.getElementById('crosshair-close-price');
            
            // Start Screen DOM Elements
            const startScreen = document.getElementById('startScreen');
            const gameScreen = document.getElementById('gameScreen');
            const stockSelector = document.getElementById('stockSelector');
            const startFundsInput = document.getElementById('startFunds');
            const startGameBtn = document.getElementById('startGameBtn');
            const startMessageArea = document.getElementById('startMessageArea');

            // Simulator DOM Elements
            const investAmountInput = document.getElementById('investAmount');
            const minusBtn = document.getElementById('minusBtn');
            const plusBtn = document.getElementById('plusBtn');
            const buyBtn = document.getElementById('buyBtn');
            const sellBtn = document.getElementById('sellBtn');
            const totalInvestedEl = document.getElementById('totalInvested');
            const remainingFundsEl = document.getElementById('remainingFunds');
            const liquidationValueEl = document.getElementById('liquidationValue');
            const realizedPnLEl = document.getElementById('realizedPnL');
            const positionsTableBody = document.querySelector('#positionsTable tbody');
            const historyTableBody = document.querySelector('#historyTable tbody');
            
            // Define padding and margins. Increased left padding for price labels.
            const padding = 60;

            // --- Initialization ---
            document.addEventListener('DOMContentLoaded', () => {
                canvas = document.getElementById('chartCanvas');
                ctx = canvas.getContext('2d');
                chartWidth = canvas.clientWidth;
                chartHeight = canvas.clientHeight;
                canvas.width = chartWidth;
                canvas.height = chartHeight;

                // Call the new function to load stocks from GitHub
                loadAvailableStocks();

                // Event Listeners
                nextDayBtn.addEventListener('click', () => stepDay(1));
                startGameBtn.addEventListener('click', startGame);

                // Simulator event listeners
                minusBtn.addEventListener('click', () => adjustInvestmentAmount(-1000));
                plusBtn.addEventListener('click', () => adjustInvestmentAmount(1000));
                buyBtn.addEventListener('click', handleBuy);
                sellBtn.addEventListener('click', handleSell);

                // Handle window resize to redraw the chart
                window.addEventListener('resize', () => {
                    chartWidth = canvas.clientWidth;
                    chartHeight = canvas.clientHeight;
                    canvas.width = chartWidth;
                    canvas.height = chartHeight;
                    if (stockData.length > 0) {
                        drawChart();
                    }
                });

                // Mouse event listeners for crosshair and date display
                canvas.addEventListener('mousemove', handleMouseMove);
                canvas.addEventListener('mouseleave', handleMouseLeave);
            });
            
            // --- GitHub Data Loading Logic ---
            async function loadAvailableStocks() {
                try {
                    showMessage('Loading available stocks from GitHub...');
                    const response = await fetch(githubApiUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    const files = await response.json();
                    
                    const stockOptions = files
                        .filter(file => file.name.endsWith('.txt'))
                        .map(file => ({
                            name: file.name.replace('.txt', ''),
                            download_url: file.download_url
                        }));

                    if (stockOptions.length > 0) {
                        populateStockSelector(stockOptions);
                        hideMessage();
                        startGameBtn.disabled = false;
                        stockSelector.disabled = false;
                        // The date picker will be enabled after a stock is selected
                        stockSelector.addEventListener('change', handleStockSelection);
                    } else {
                        showMessage('No valid stock data files found in the repository.');
                    }
                } catch (error) {
                    console.error("Error loading stocks from GitHub:", error);
                    showMessage('Error: Could not load data from GitHub. Please check the URL.');
                }
            }

            async function handleStockSelection() {
                const selectedOption = stockSelector.options[stockSelector.selectedIndex];
                const downloadUrl = selectedOption.dataset.downloadUrl;

                if (!downloadUrl) return;

                try {
                    showMessage('Loading stock data...');
                    const response = await fetch(downloadUrl);
                    const content = await response.text();
                    allStockData = parseData(content);
                    if (allStockData.length > 0) {
                        updateDatePickerRange();
                        datePicker.disabled = false;
                        hideMessage();
                    } else {
                        showMessage('No valid data found for this stock.');
                    }
                } catch (error) {
                    console.error("Error fetching stock data:", error);
                    showMessage('Error: Could not fetch stock data.');
                }
            }
            
            // --- Start Screen Logic ---
            function adjustInvestmentAmount(change) {
                let currentAmount = parseFloat(investAmountInput.value);
                let newAmount = currentAmount + change;
                if (newAmount >= 1000) {
                    investAmountInput.value = newAmount;
                }
            }

            function startGame() {
                const selectedStock = stockSelector.value;
                const endDateStr = datePicker.value;
                const initialFunds = parseFloat(startFundsInput.value);

                if (!selectedStock) {
                    startMessageArea.textContent = 'Please select a stock.';
                    startMessageArea.classList.remove('hidden');
                    return;
                }
                
                if (!endDateStr) {
                    startMessageArea.textContent = 'Please select an end date.';
                    startMessageArea.classList.remove('hidden');
                    return;
                }
                
                if (initialFunds <= 0 || isNaN(initialFunds)) {
                     startMessageArea.textContent = 'Please enter valid starting funds.';
                     startMessageArea.classList.remove('hidden');
                     return;
                }

                startMessageArea.classList.add('hidden');
                
                // Filter data based on user selection
                stockData = allStockData.filter(item => item.stock === selectedStock);
                const endDate = new Date(endDateStr);
                const endIndex = stockData.findIndex(item => formatDate(item.date) === endDateStr);

                if (endIndex === -1) {
                    startMessageArea.textContent = 'Invalid end date for selected stock. Please choose another.';
                    startMessageArea.classList.remove('hidden');
                    return;
                }
                
                stockData = stockData.slice(0, endIndex + 1);
                
                if (stockData.length === 0) {
                    startMessageArea.textContent = 'No data available for the selected range.';
                    startMessageArea.classList.remove('hidden');
                    return;
                }

                // Initialize game state
                startFunds = initialFunds;
                remainingFunds = initialFunds;
                totalInvestedAmount = 0;
                totalRealizedPnL = 0;
                portfolio = {};
                transactionHistory = [];
                currentIndex = 0;
                
                // Switch screens
                startScreen.classList.add('hidden');
                gameScreen.classList.remove('hidden');
                
                // Initialize game UI
                drawChart();
                updateSimulatorButtons();
                updatePortfolioValues();
                renderPortfolio();
                renderHistory();
            }

            // --- Data Processing and Parsing ---
            function parseData(text) {
                const lines = text.trim().split('\n').slice(1);
                return lines.map(line => {
                    const parts = line.split(',');
                    const dateStr = parts[2];
                    const date = new Date(dateStr.substring(0, 4), dateStr.substring(4, 6) - 1, dateStr.substring(6, 8));
                    
                    return {
                        date: date,
                        stock: parts[0],
                        open: parseFloat(parts[4]),
                        high: parseFloat(parts[5]),
                        low: parseFloat(parts[6]),
                        close: parseFloat(parts[7])
                    };
                }).filter(item => !isNaN(item.open) && !isNaN(item.high) && !isNaN(item.low) && !isNaN(item.close));
            }
            
            function populateStockSelector(stockOptions) {
                stockSelector.innerHTML = '';
                stockOptions.forEach(stock => {
                    const option = document.createElement('option');
                    option.value = stock.name;
                    option.textContent = stock.name;
                    option.dataset.downloadUrl = stock.download_url;
                    stockSelector.appendChild(option);
                });
            }

            function updateDatePickerRange() {
                if (allStockData.length > 0) {
                    const firstDate = allStockData[0].date;
                    const lastDate = allStockData[allStockData.length - 1].date;
                    datePicker.min = formatDate(firstDate);
                    datePicker.max = formatDate(lastDate);
                }
            }
            
            function stepDay(direction) {
                const newIndex = currentIndex + direction;
                if (newIndex >= 0 && newIndex < stockData.length) {
                    currentIndex = newIndex;
                    drawChart();
                }
                updateSimulatorButtons();
            }
            
            // --- Chart Drawing Logic ---
            function drawChart() {
                ctx.clearRect(0, 0, chartWidth, chartHeight);
                if (stockData.length === 0) return;

                // Display all data up to the current day
                dataToDisplay = stockData.slice(0, currentIndex + 1);
                if (dataToDisplay.length === 0) return;

                const prices = dataToDisplay.flatMap(d => [d.high, d.low]);
                maxPrice = Math.max(...prices);
                minPrice = Math.min(...prices);

                const pricePadding = (maxPrice - minPrice) * 0.1;
                const chartAreaWidth = chartWidth - padding * 2;
                const chartAreaHeight = chartHeight - padding * 2;

                priceScale = chartAreaHeight / ((maxPrice - minPrice) + 2 * pricePadding);
                const dateScale = chartAreaWidth / dataToDisplay.length;

                ctx.strokeStyle = '#6b7280';
                ctx.beginPath();
                ctx.moveTo(padding, chartHeight - padding);
                ctx.lineTo(chartWidth - padding, chartHeight - padding);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(padding, padding);
                ctx.lineTo(padding, chartHeight - padding);
                ctx.stroke();

                let previousMonth = -1;
                let previousYear = -1;
                dataToDisplay.forEach((day, index) => {
                    const x = padding + index * dateScale + dateScale / 2;
                    const openY = chartHeight - padding - (day.open - minPrice + pricePadding) * priceScale;
                    const highY = chartHeight - padding - (day.high - minPrice + pricePadding) * priceScale;
                    const lowY = chartHeight - padding - (day.low - minPrice + pricePadding) * priceScale;
                    const closeY = chartHeight - padding - (day.close - minPrice + pricePadding) * priceScale;

                    const isBullish = day.close >= day.open;
                    ctx.strokeStyle = isBullish ? '#10b981' : '#ef4444';
                    ctx.fillStyle = isBullish ? '#10b981' : '#ef4444';

                    ctx.beginPath();
                    ctx.moveTo(x, highY);
                    ctx.lineTo(x, lowY);
                    ctx.stroke();

                    const bodyHeight = Math.abs(openY - closeY) || 1;
                    const bodyWidth = dateScale * 0.7;
                    ctx.fillRect(x - bodyWidth / 2, Math.min(openY, closeY), bodyWidth, bodyHeight);

                    const currentMonth = day.date.getMonth();
                    const currentYear = day.date.getFullYear();
                    
                    if (index > 0 && currentMonth !== previousMonth) {
                        ctx.strokeStyle = '#4b5563';
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(x, padding);
                        ctx.lineTo(x, chartHeight - padding);
                        ctx.stroke();
                        ctx.setLineDash([]);

                        ctx.fillStyle = '#9ca3af';
                        ctx.font = '10px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        const dateText = `${monthNames[currentMonth]} ${day.date.getDate()}`;
                        ctx.fillText(dateText, x, chartHeight - padding + 20);
                    }

                    if (index > 0 && currentYear !== previousYear) {
                        ctx.fillStyle = '#9ca3af';
                        ctx.font = '12px Inter, sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(currentYear, x, chartHeight - padding + 40);
                    }

                    previousMonth = currentMonth;
                    previousYear = currentYear;
                });

                ctx.fillStyle = '#9ca3af';
                ctx.font = '10px Inter, sans-serif';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                const yAxisLabels = 5;
                for (let i = 0; i <= yAxisLabels; i++) {
                    const price = minPrice + pricePadding + (maxPrice - minPrice) * (i / yAxisLabels);
                    const y = chartHeight - padding - (price - minPrice + pricePadding) * priceScale;
                    ctx.fillText(price.toFixed(2), padding - 10, y);
                }
                
                // Update portfolio values with the current day's data
                if (dataToDisplay.length > 0) {
                     updateLiquidationValue(dataToDisplay[dataToDisplay.length - 1].close);
                }
            }

            // --- Crosshair and Date/Price Display Logic ---
            let crosshairX, crosshairY;

            function handleMouseMove(event) {
                if (stockData.length === 0) return;
                const rect = canvas.getBoundingClientRect();
                crosshairX = event.clientX - rect.left;
                crosshairY = event.clientY - rect.top;

                const chartAreaX = crosshairX >= padding && crosshairX <= chartWidth - padding;
                const chartAreaY = crosshairY >= padding && crosshairY <= chartHeight - padding;

                if (chartAreaX && chartAreaY) {
                    drawChart();
                    const dataIndex = getNearestCandleIndex(crosshairX);
                    if (dataIndex !== -1) {
                        const snappedX = getCandleXPosition(dataIndex);
                        drawCrosshair(snappedX, crosshairY);
                        displayCrosshairInfo(snappedX, crosshairY, dataIndex);
                        displayClosePrice(dataToDisplay[dataIndex].close);
                        updateLiquidationValue(dataToDisplay[dataIndex].close);
                    } else {
                         handleMouseLeave();
                    }
                } else {
                    handleMouseLeave();
                }
            }

            function handleMouseLeave() {
                drawChart();
                crosshairDateEl.style.opacity = 0;
                crosshairPriceEl.style.opacity = 0;
                crosshairClosePriceEl.style.opacity = 0;
                
                // When leaving the chart, reset the liquidation value to the last visible candle's close price
                if (dataToDisplay.length > 0) {
                     updateLiquidationValue(dataToDisplay[dataToDisplay.length - 1].close);
                }
            }

            function drawCrosshair(x, y) {
                ctx.setLineDash([2, 2]);
                ctx.strokeStyle = '#ffffff';

                ctx.beginPath();
                ctx.moveTo(x, padding);
                ctx.lineTo(x, chartHeight - padding);
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(padding, y);
                ctx.lineTo(chartWidth - padding, y);
                ctx.stroke();

                ctx.setLineDash([]);
            }

            function displayCrosshairInfo(x, y, dataIndex) {
                const day = dataToDisplay[dataIndex];
                const formattedDate = formatCrosshairDate(day.date);
                crosshairDateEl.textContent = formattedDate;
                crosshairDateEl.style.left = `${x}px`;
                crosshairDateEl.style.opacity = 1;

                const price = yToPrice(y);
                crosshairPriceEl.textContent = price.toFixed(2);
                crosshairPriceEl.style.top = `${y}px`;
                crosshairPriceEl.style.opacity = 1;
            }

            function displayClosePrice(price) {
                crosshairClosePriceEl.textContent = `Close: ${price.toFixed(2)}`;
                crosshairClosePriceEl.style.opacity = 1;
            }

            function formatCrosshairDate(date) {
                const d = new Date(date);
                const day = String(d.getDate()).padStart(2, '0');
                const month = monthNames[d.getMonth()];
                const year = d.getFullYear();
                return `${day}-${month}-${year}`;
            }

            function getNearestCandleIndex(x) {
                const chartAreaWidth = chartWidth - padding * 2;
                const dateScale = chartAreaWidth / dataToDisplay.length;
                const index = Math.floor((x - padding + dateScale / 2) / dateScale);
                if (index >= 0 && index < dataToDisplay.length) {
                    return index;
                }
                return -1;
            }

            function getCandleXPosition(index) {
                const chartAreaWidth = chartWidth - padding * 2;
                const dateScale = chartAreaWidth / dataToDisplay.length;
                return padding + index * dateScale + dateScale / 2;
            }
            
            function priceToY(price) {
                const pricePadding = (maxPrice - minPrice) * 0.1;
                return chartHeight - padding - (price - minPrice + pricePadding) * priceScale;
            }

            function yToPrice(y) {
                const chartAreaHeight = chartHeight - padding * 2;
                const pricePadding = (maxPrice - minPrice) * 0.1;
                const relativeY = chartHeight - padding - y;
                const priceRange = (maxPrice - minPrice) + 2 * pricePadding;
                const price = (relativeY / chartAreaHeight) * priceRange + minPrice - pricePadding;
                return price;
            }

            // --- Simulator Logic ---
            function handleBuy() {
                if (stockData.length === 0 || currentIndex === -1) return;
                const currentDay = stockData[currentIndex];
                const currentPrice = currentDay.close;
                const maxInvestment = parseFloat(investAmountInput.value);
                
                if (currentPrice <= 0 || maxInvestment <= 0 || isNaN(maxInvestment)) return;

                const sharesToBuy = Math.floor(maxInvestment / currentPrice);
                if (sharesToBuy === 0) {
                     console.log("Maximum investment is too small to buy even one share.");
                    return;
                }

                const cost = sharesToBuy * currentPrice;
                const stock = currentDay.stock;

                if (cost > remainingFunds) {
                    console.log("Not enough funds to buy shares.");
                    return;
                }

                if (portfolio[stock]) {
                    // Update existing position
                    const currentShares = portfolio[stock].shares;
                    const currentCost = currentShares * portfolio[stock].avgPrice;
                    const newTotalShares = currentShares + sharesToBuy;
                    const newTotalCost = currentCost + cost;
                    const newAvgPrice = newTotalCost / newTotalShares;
                    
                    portfolio[stock].shares = newTotalShares;
                    portfolio[stock].avgPrice = newAvgPrice;
                } else {
                    // Create new position
                    portfolio[stock] = {
                        shares: sharesToBuy,
                        avgPrice: currentPrice
                    };
                }

                totalInvestedAmount += cost;
                remainingFunds -= cost;
                
                // Add to history
                transactionHistory.push({
                    date: currentDay.date,
                    operation: 'Buy',
                    shares: sharesToBuy,
                    price: currentPrice,
                    realizedPnL: 0
                });

                updatePortfolioValues();
                renderPortfolio();
                renderHistory();
            }

            function handleSell() {
                if (stockData.length === 0 || currentIndex === -1) return;
                const currentDay = stockData[currentIndex];
                const currentPrice = currentDay.close;
                const stock = currentDay.stock;
                
                if (!portfolio[stock] || portfolio[stock].shares === 0) {
                    console.log("No shares to sell.");
                    return;
                }

                const sharesToSell = portfolio[stock].shares;
                const avgPrice = portfolio[stock].avgPrice;
                const gainLoss = (currentPrice - avgPrice) * sharesToSell;

                totalRealizedPnL += gainLoss;
                remainingFunds += currentPrice * sharesToSell;
                
                totalInvestedAmount -= sharesToSell * avgPrice;
                
                // Add to history
                transactionHistory.push({
                    date: currentDay.date,
                    operation: 'Sell',
                    shares: sharesToSell,
                    price: currentPrice,
                    realizedPnL: gainLoss
                });
                
                // Remove from portfolio
                delete portfolio[stock];

                updatePortfolioValues();
                renderPortfolio();
                renderHistory();
            }

            function updateLiquidationValue(currentPrice) {
                let openPositionsValue = 0;
                for (const stock in portfolio) {
                    openPositionsValue += portfolio[stock].shares * currentPrice;
                }
                liquidationValue = remainingFunds + openPositionsValue;
                updatePortfolioValues();
            }

            function updatePortfolioValues() {
                totalInvestedEl.textContent = `$${totalInvestedAmount.toFixed(2)}`;
                remainingFundsEl.textContent = `$${remainingFunds.toFixed(2)}`;
                liquidationValueEl.textContent = `$${liquidationValue.toFixed(2)}`;
                realizedPnLEl.textContent = `$${totalRealizedPnL.toFixed(2)}`;
                
                // Style the P&L text
                realizedPnLEl.classList.remove('text-red-500', 'text-green-500');
                if (totalRealizedPnL > 0) realizedPnLEl.classList.add('text-green-500');
                if (totalRealizedPnL < 0) realizedPnLEl.classList.add('text-red-500');

                liquidationValueEl.classList.remove('text-red-500', 'text-green-500');
                if (liquidationValue > startFunds) liquidationValueEl.classList.add('text-green-500');
                if (liquidationValue < startFunds) liquidationValueEl.classList.add('text-red-500');
            }

            function renderPortfolio() {
                positionsTableBody.innerHTML = '';
                for (const stock in portfolio) {
                    const position = portfolio[stock];
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${stock}</td>
                        <td>${position.shares.toFixed(0)}</td>
                        <td>$${position.avgPrice.toFixed(2)}</td>
                    `;
                    positionsTableBody.appendChild(row);
                }
            }

            function renderHistory() {
                historyTableBody.innerHTML = '';
                // Render in reverse chronological order
                [...transactionHistory].reverse().forEach(movement => {
                    const row = document.createElement('tr');
                    let pnlColorClass = '';
                    if (movement.operation === 'Sell') {
                        if (movement.realizedPnL > 0) pnlColorClass = 'text-green-500';
                        if (movement.realizedPnL < 0) pnlColorClass = 'text-red-500';
                    }
                    row.innerHTML = `
                        <td>${formatDate(movement.date)}</td>
                        <td>${movement.operation}</td>
                        <td>${movement.shares.toFixed(0)}</td>
                        <td>$${movement.price.toFixed(2)}</td>
                        <td class="${pnlColorClass}">$${movement.realizedPnL.toFixed(2)}</td>
                    `;
                    historyTableBody.appendChild(row);
                });
            }

            // --- UI Helpers ---
            function formatDate(date) {
                if (!date) return '';
                const d = new Date(date);
                const year = d.getFullYear();
                const month = String(d.getMonth() + 1).padStart(2, '0');
                const day = String(d.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            }

            function updateSimulatorButtons() {
                if (currentIndex >= stockData.length - 1) {
                    nextDayBtn.disabled = true;
                    buyBtn.disabled = true;
                    sellBtn.disabled = true;
                } else {
                    nextDayBtn.disabled = false;
                    buyBtn.disabled = false;
                    sellBtn.disabled = false;
                }
            }

            function showMessage(msg) {
                messageArea.classList.remove('hidden');
                messageArea.querySelector('p').textContent = msg;
                if(nextDayBtn) nextDayBtn.disabled = true;
                if(buyBtn) buyBtn.disabled = true;
                if(sellBtn) sellBtn.disabled = true;
            }

            function hideMessage() {
                messageArea.classList.add('hidden');
            }
        })();
    </script>
</body>
</html>
